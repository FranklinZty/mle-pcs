#!/usr/bin/env python3

import os
import datetime
from pathlib import Path

# Define the name of the CSS file
CSS_FILENAME = "style.css"

# HTML templates
HTML_TEMPLATE_START = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Repository</title>
    <link rel="stylesheet" href="{css_filename}">
</head>
<body>
    <header>
        <h1>PDF Repository</h1>
        <p>Last updated: {build_time}</p>
    </header>
    <main>
"""

HTML_TEMPLATE_END = """
    </main>
    <footer>
        <p>Generated by gen_index.py on {build_time}</p>
    </footer>
</body>
</html>
"""

def collect_pdfs(root_dir):
    """
    Traverse the root_dir and collect all PDF files organized by their directories.

    Args:
        root_dir (str): The root directory to start searching from.

    Returns:
        dict: A dictionary with directory names as keys and lists of PDF info as values.
    """
    pdf_dict = {}
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Skip hidden directories
        dirnames[:] = [d for d in dirnames if not d.startswith('.')]
        
        # Calculate relative directory path from root
        rel_dir = os.path.relpath(dirpath, root_dir)
        if rel_dir == ".":
            rel_dir = "Root"

        pdf_files = []
        for file in filenames:
            if file.lower().endswith('.pdf'):
                file_path = os.path.join(dirpath, file)
                # Get last modified time
                mtime = datetime.datetime.fromtimestamp(os.path.getmtime(file_path))
                # Format datetime
                mtime_str = mtime.strftime("%Y-%m-%d %H:%M:%S")
                # Relative URL for linking
                rel_url = os.path.relpath(file_path, root_dir).replace('\\', '/')
                pdf_files.append({
                    'name': file,
                    'url': rel_url,
                    'mtime': mtime_str
                })
        if pdf_files:
            # Sort PDF files alphabetically
            pdf_files.sort(key=lambda x: x['name'].lower())
            pdf_dict[rel_dir] = pdf_files

    # Sort directories alphabetically
    sorted_pdf_dict = dict(sorted(pdf_dict.items(), key=lambda x: x[0].lower()))
    return sorted_pdf_dict

def generate_html(pdf_dict, build_time, css_filename):
    """
    Generate the complete HTML content.

    Args:
        pdf_dict (dict): Dictionary of directories and their PDF files.
        build_time (str): Timestamp of when the HTML was generated.
        css_filename (str): The CSS file name to link.

    Returns:
        str: The complete HTML content.
    """
    html_content = HTML_TEMPLATE_START.format(css_filename=css_filename, build_time=build_time)
    
    for directory, pdfs in pdf_dict.items():
        html_content += f"        <section>\n"
        html_content += f"            <h2>{directory}</h2>\n"
        html_content += f"            <ul>\n"
        for pdf in pdfs:
            html_content += f"                <li><a href=\"{pdf['url']}\" target=\"_blank\" rel=\"noopener noreferrer\">{pdf['name']}</a> <span class=\"mtime\">({pdf['mtime']})</span></li>\n"
        html_content += f"            </ul>\n"
        html_content += f"        </section>\n"

    html_content += HTML_TEMPLATE_END.format(build_time=build_time)
    return html_content

def generate_css(css_path):
    """
    Generate the CSS styling for the HTML page.

    Args:
        css_path (str): Path where the CSS file will be saved.
    """
    css_content = """
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f4;
    color: #333;
    line-height: 1.6;
    padding: 20px;
}

header {
    text-align: center;
    margin-bottom: 40px;
}

header h1 {
    font-size: 2.5em;
    margin-bottom: 10px;
}

header p {
    color: #666;
}

main {
    max-width: 800px;
    margin: 0 auto;
}

section {
    background: #fff;
    padding: 20px;
    margin-bottom: 20px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

section h2 {
    margin-bottom: 15px;
    color: #007acc;
}

ul {
    list-style: none;
}

li {
    padding: 10px 0;
    border-bottom: 1px solid #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

li:last-child {
    border-bottom: none;
}

a {
    text-decoration: none;
    color: #333;
    transition: color 0.3s ease;
}

a:hover {
    color: #007acc;
}

.mtime {
    font-size: 0.9em;
    color: #999;
}

footer {
    text-align: center;
    margin-top: 40px;
    color: #666;
    font-size: 0.9em;
}

@media (max-width: 600px) {
    body {
        padding: 10px;
    }

    header h1 {
        font-size: 2em;
    }

    section {
        padding: 15px;
    }

    li {
        flex-direction: column;
        align-items: flex-start;
    }

    .mtime {
        margin-top: 5px;
    }
}
"""
    with open(css_path, 'w', encoding='utf-8') as css_file:
        css_file.write(css_content.strip())

def main():
    # Define root directory (current directory)
    root_dir = os.getcwd()

    # Collect PDF files
    pdf_dict = collect_pdfs(root_dir)

    # Get current timestamp
    build_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Generate CSS file
    css_path = os.path.join(root_dir, CSS_FILENAME)
    generate_css(css_path)

    # Generate HTML content
    html_content = generate_html(pdf_dict, build_time, CSS_FILENAME)

    # Write to index.html
    index_path = os.path.join(root_dir, "index.html")
    with open(index_path, 'w', encoding='utf-8') as html_file:
        html_file.write(html_content)

    print(f"index.html and {CSS_FILENAME} have been generated successfully.")

if __name__ == "__main__":
    main()